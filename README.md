# All about Tomcat

> Server v/s Web Server v/s Servlet Container

---

### **1. Key Terms**
#### **a) Server:**
   - A **server** is just a powerful computer (or software) that "serves" requests. 
   - Example: When you visit `google.com`, your browser (client) asks Google’s server for the webpage.

#### **b) Web Server:**
   - A **web server** handles **HTTP requests** (like GET, POST) and serves static content (HTML, CSS, images).
   - Example: **Apache HTTP Server**, **Nginx**.
   - *Limitation*: It can’t run Java code dynamically.

#### **c) Servlet:**
   - A **Servlet** is a Java class that runs on a server to handle dynamic requests (e.g., processing form data, talking to a database).
   - Example: If you login to a website, a Servlet might check your username/password.

#### **d) Container:**
   - A **container** is like a "runtime environment" that manages components (e.g., Servlets). It provides them with resources, lifecycle management, and security.
   - Think of it like an **OS for Servlets** – it starts, stops, and manages them.

---

### **2. What is Tomcat?**
**Apache Tomcat** is a **Servlet Container** (also called a *web container* or *Servlet engine*).  
- It’s a server that can **run Java Servlets** (dynamic Java code).
- It also includes a basic **HTTP web server**, so it can serve static files too (but it’s not as powerful as Nginx/Apache HTTP Server).

#### **Tomcat’s Job:**
1. **Listens** for HTTP requests (e.g., `http://localhost:8080`).
2. **Routes** requests to the correct Servlet (Java code).
3. **Manages** Servlets (starts, stops, multithreading, security).
4. **Sends back** the dynamic response (e.g., HTML generated by Java).

---

### **3. Why is Tomcat Everywhere?**
Tomcat is lightweight, free, and widely used. Here’s why you see it in:
- **Grails/Spring MVC**: These frameworks use Servlets internally. Tomcat runs them.
- **Spring Boot**: Embeds Tomcat by default (no separate install needed) to simplify deployment.

---

### **4. Key Takeaways**
- Tomcat = **Servlet Container** + **Basic Web Server**.
- It runs **Java Servlets** (dynamic code).
- Frameworks like Spring Boot **embed Tomcat** so you don’t need to set it up separately.
- Alternatives: Jetty, Undertow (similar to Tomcat but with different features).

---

### **5. Example Flow (Tomcat in Action)**
1. You visit `http://localhost:8080/login`.
2. Tomcat (web server part) receives the request.
3. Tomcat (container part) finds the `LoginServlet` Java class.
4. `LoginServlet` runs, checks your credentials in a database.
5. Tomcat sends back the response (e.g., "Welcome, User!").

---

### **6. Summary**
- **Tomcat** = A server that runs Java Servlets (dynamic web apps).
- **Servlet** = Java class handling HTTP requests.
- **Container** = Manages Servlets’ lifecycle.


-----
<br/>





> So can I create a simple Java Servlet & run it on Web server ? I don't want to use Tomcat so that I understand Servlets independently. 


Great question! To clarify: **Servlets cannot run without a Servlet Container** (like Tomcat, Jetty, or Undertow). A Servlet is just a Java class, but it needs a container to:  
- Handle HTTP requests/responses.  
- Manage the Servlet lifecycle (`init()`, `service()`, `destroy()`).  
- Provide threading, security, and deployment features.  

However, you can **write a simple Servlet without using a full framework like Spring Boot** and then run it on a lightweight Servlet Container (like embedded Tomcat or Jetty). Let’s break this down:

---

### **Option 1: Pure Servlet + Embedded Tomcat (Minimal Setup)**
Even if you avoid "traditional" Tomcat, you’ll still need a container. Here’s the simplest way:

#### **Step 1: Write a Servlet**
```java
import java.io.*;
import jakarta.servlet.*;
import jakarta.servlet.http.*;

public class HelloServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) 
            throws ServletException, IOException {
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h1>Hello, World! This is a raw Servlet.</h1>");
        out.println("</body></html>");
    }
}
```
- This Servlet responds to `GET /hello` with HTML.

#### **Step 2: Add Dependencies (Maven)**
You need the Servlet API (Jakarta EE) and an embedded container like Tomcat:
```xml
<dependencies>
    <!-- Servlet API -->
    <dependency>
        <groupId>jakarta.servlet</groupId>
        <artifactId>jakarta.servlet-api</artifactId>
        <version>6.0.0</version>
        <scope>provided</scope>
    </dependency>
    <!-- Embedded Tomcat -->
    <dependency>
        <groupId>org.apache.tomcat.embed</groupId>
        <artifactId>tomcat-embed-core</artifactId>
        <version>10.1.18</version>
    </dependency>
</dependencies>
```

#### **Step 3: Run with Embedded Tomcat**
```java
import org.apache.catalina.startup.Tomcat;
import java.io.File;

public class Main {
    public static void main(String[] args) throws Exception {
        Tomcat tomcat = new Tomcat();
        tomcat.setPort(8080);

        // Define context path and Servlet
        String contextPath = "";
        String docBase = new File(".").getAbsolutePath();
        
        tomcat.addWebapp(contextPath, docBase);
        tomcat.addServlet(contextPath, "HelloServlet", new HelloServlet());
        tomcat.addServletMappingDecoded("/hello", "HelloServlet");

        tomcat.start();
        tomcat.getServer().await();
    }
}
```
- Run `Main.java`, then visit:  
  **http://localhost:8080/hello**

---

### **Option 2: Use Jetty (Alternative to Tomcat)**
If you truly want to avoid Tomcat, Jetty is another lightweight container:
```xml
<dependency>
    <groupId>org.eclipse.jetty</groupId>
    <artifactId>jetty-server</artifactId>
    <version>11.0.20</version>
</dependency>
<dependency>
    <groupId>org.eclipse.jetty</groupId>
    <artifactId>jetty-servlet</artifactId>
    <version>11.0.20</version>
</dependency>
```
```java
import org.eclipse.jetty.server.Server;
import org.eclipse.jetty.servlet.ServletHandler;

public class JettyMain {
    public static void main(String[] args) throws Exception {
        Server server = new Server(8080);
        ServletHandler handler = new ServletHandler();
        server.setHandler(handler);

        handler.addServletWithMapping(HelloServlet.class, "/hello");
        server.start();
        server.join();
    }
}
```

---

### **Key Takeaways**
1. **Servlets require a container** (Tomcat/Jetty/etc.) to run.  
2. You can avoid "installing Tomcat" by using an **embedded** version (like above).  
3. Frameworks like Spring Boot hide this complexity by embedding Tomcat/Jetty automatically.  

---

### **Why Can’t You Use a Plain Web Server (e.g., Nginx)?**
- A web server (Nginx/Apache) only serves static files.  
- Servlets are **Java code** that need a JVM and a runtime to execute dynamically.  
- The Servlet Container bridges HTTP and Java (e.g., converts HTTP requests to `HttpServletRequest` objects).  

---

### **Experiment Suggestion**
Try running the embedded Tomcat example above. You’ll see:  
1. How a raw Servlet works.  
2. How the container manages it.  
3. Why frameworks abstract this away (for convenience).  



-----
<br>

> Would like to know how Containers manage Servlets ?


Great question! Let’s break down **how a Servlet Container (like Tomcat or Jetty) manages Servlets** in a way that’s easy to visualize. Think of the container as a "backstage manager" for your Servlets, handling everything from birth to death, multitasking, and even emergencies.

---

### **1. Servlet Lifecycle Management**
A container controls the entire lifecycle of a Servlet through three key methods:  
```java
public class MyServlet extends HttpServlet {
    // 1. Born (Container calls this once)
    public void init(ServletConfig config) throws ServletException {
        System.out.println("Servlet initialized!");
    }

    // 2. Working (Handles requests)
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) { ... }

    // 3. Death (Container calls this before destroying)
    public void destroy() {
        System.out.println("Servlet destroyed!");
    }
}
```
#### **What the Container Does:**
| **Lifecycle Stage** | **Container’s Role**                                                                 |
|---------------------|-------------------------------------------------------------------------------------|
| **Initialization**  | Calls `init()` once when the Servlet is first loaded (e.g., on startup or first request). |
| **Request Handling**| Creates threads to call `doGet()`, `doPost()`, etc., for each HTTP request.          |
| **Destruction**     | Calls `destroy()` when shutting down (e.g., to release database connections).        |

**Key Point:** You *never* call these methods directly—the container does!

---

### **2. Threading & Concurrency**
- The container **creates a new thread** for each incoming request (so multiple users can use the Servlet simultaneously).  
- Your `doGet()`/`doPost()` code must be **thread-safe** (avoid shared mutable state).  

#### **Example:**
```java
// UNSAFE (Shared variable across threads!)
public class BadServlet extends HttpServlet {
    int count = 0; // Danger! Race condition!
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        count++;
    }
}
```
The container’s threading model is why Servlets are **scalable** but require careful coding.

---

### **3. Request/Response Handling**
The container wraps raw HTTP traffic into Java objects:  
- **`HttpServletRequest`**: Contains HTTP headers, parameters, body.  
- **`HttpServletResponse`**: Lets you set status codes, headers, and write output.  

#### **Behind the Scenes:**
1. You visit `http://localhost:8080/hello?name=Alice`.  
2. The container:  
   - Parses the URL and parameters.  
   - Creates `HttpServletRequest`/`HttpServletResponse` objects.  
   - Passes them to your `doGet()` method.  

---

### **4. Deployment & Configuration**
Servlets are deployed via:  
- **`web.xml` (Traditional)**  
  ```xml
  <web-app>
    <servlet>
      <servlet-name>hello</servlet-name>
      <servlet-class>com.example.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello</url-pattern>
    </servlet-mapping>
  </web-app>
  ```
- **Annotations (Modern)**  
  ```java
  @WebServlet("/hello")
  public class HelloServlet extends HttpServlet { ... }
  ```
The container reads these and maps URLs to Servlets.

---

### **5. Memory & Resource Management**
- **Classloading**: The container loads/unloads Servlet classes (e.g., during hot deployment).  
- **Pooling**: Reuses Servlets instead of creating new instances per request.  
- **Cleanup**: Calls `destroy()` to release resources (e.g., closing database connections).  

---

### **6. Security**
The container handles:  
- Authentication (e.g., login pages).  
- Authorization (e.g., role-based access via `@RolesAllowed`).  
- HTTPS/SSL termination.  

---

### **7. Error Handling**
- Catches exceptions thrown by Servlets.  
- Shows default error pages or custom ones (configured in `web.xml`).  

---

### **Analogy: Restaurant Kitchen**
| **Container’s Job**         | **Restaurant Analogy**                          |
|-----------------------------|-----------------------------------------------|
| Manages Servlet lifecycle   | Hires chefs (`init()`), fires them (`destroy()`). |
| Handles threading           | Multiple chefs cook different orders at once.  |
| Wraps HTTP requests         | Waiter translates customer orders to recipes.  |
| Manages deployment          | Assigns chefs to stations (URL mappings).     |

---

### **Key Takeaways**
1. **Containers are invisible superheroes**: They handle everything low-level so you can focus on `doGet()`/`doPost()`.  
2. **Threading is automatic but dangerous**: Shared state causes bugs (race conditions).  
3. **Lifecycle matters**: Use `init()` for startup tasks (e.g., DB connections), `destroy()` for cleanup.  

---

### **Experiment to Try**
1. Add `System.out.println("Thread: " + Thread.currentThread().getId())` to your `doGet()`.  
   - Refresh the page multiple times—see different thread IDs!  
2. Add a `sleep(5000)` to simulate slow processing.  
   - Open two browser tabs—note how the container handles concurrent requests.  

This will solidify how containers manage Servlets in practice. Want to dive deeper into any area?



