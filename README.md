# All about Tomcat

> Server v/s Web Server v/s Servlet Container

---

### **1. Key Terms**
#### **a) Server:**
   - A **server** is just a powerful computer (or software) that "serves" requests. 
   - Example: When you visit `google.com`, your browser (client) asks Google’s server for the webpage.

#### **b) Web Server:**
   - A **web server** handles **HTTP requests** (like GET, POST) and serves static content (HTML, CSS, images).
   - Example: **Apache HTTP Server**, **Nginx**.
   - *Limitation*: It can’t run Java code dynamically.

#### **c) Servlet:**
   - A **Servlet** is a Java class that runs on a server to handle dynamic requests (e.g., processing form data, talking to a database).
   - Example: If you login to a website, a Servlet might check your username/password.

#### **d) Container:**
   - A **container** is like a "runtime environment" that manages components (e.g., Servlets). It provides them with resources, lifecycle management, and security.
   - Think of it like an **OS for Servlets** – it starts, stops, and manages them.

---

### **2. What is Tomcat?**
**Apache Tomcat** is a **Servlet Container** (also called a *web container* or *Servlet engine*).  
- It’s a server that can **run Java Servlets** (dynamic Java code).
- It also includes a basic **HTTP web server**, so it can serve static files too (but it’s not as powerful as Nginx/Apache HTTP Server).

#### **Tomcat’s Job:**
1. **Listens** for HTTP requests (e.g., `http://localhost:8080`).
2. **Routes** requests to the correct Servlet (Java code).
3. **Manages** Servlets (starts, stops, multithreading, security).
4. **Sends back** the dynamic response (e.g., HTML generated by Java).

---

### **3. Why is Tomcat Everywhere?**
Tomcat is lightweight, free, and widely used. Here’s why you see it in:
- **Grails/Spring MVC**: These frameworks use Servlets internally. Tomcat runs them.
- **Spring Boot**: Embeds Tomcat by default (no separate install needed) to simplify deployment.

---

### **4. Key Takeaways**
- Tomcat = **Servlet Container** + **Basic Web Server**.
- It runs **Java Servlets** (dynamic code).
- Frameworks like Spring Boot **embed Tomcat** so you don’t need to set it up separately.
- Alternatives: Jetty, Undertow (similar to Tomcat but with different features).

---

### **5. Example Flow (Tomcat in Action)**
1. You visit `http://localhost:8080/login`.
2. Tomcat (web server part) receives the request.
3. Tomcat (container part) finds the `LoginServlet` Java class.
4. `LoginServlet` runs, checks your credentials in a database.
5. Tomcat sends back the response (e.g., "Welcome, User!").

---

### **6. Summary**
- **Tomcat** = A server that runs Java Servlets (dynamic web apps).
- **Servlet** = Java class handling HTTP requests.
- **Container** = Manages Servlets’ lifecycle.


-----
<br/>





> So can I create a simple Java Servlet & run it on Web server ? I don't want to use Tomcat so that I understand Servlets independently. 


Great question! To clarify: **Servlets cannot run without a Servlet Container** (like Tomcat, Jetty, or Undertow). A Servlet is just a Java class, but it needs a container to:  
- Handle HTTP requests/responses.  
- Manage the Servlet lifecycle (`init()`, `service()`, `destroy()`).  
- Provide threading, security, and deployment features.  

[Creating Simple servlet and deploying it to Tomcat](https://github.com/codesuman/tomcat-playground/tree/static-servlet) 

-----
<br>

> Would like to know how Containers manage Servlets ?


Great question! Let’s break down **how a Servlet Container (like Tomcat or Jetty) manages Servlets** in a way that’s easy to visualize. Think of the container as a "backstage manager" for your Servlets, handling everything from birth to death, multitasking, and even emergencies.

---

### **1. Servlet Lifecycle Management**
A container controls the entire lifecycle of a Servlet through three key methods:  
```java
public class MyServlet extends HttpServlet {
    // 1. Born (Container calls this once)
    public void init(ServletConfig config) throws ServletException {
        System.out.println("Servlet initialized!");
    }

    // 2. Working (Handles requests)
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) { ... }

    // 3. Death (Container calls this before destroying)
    public void destroy() {
        System.out.println("Servlet destroyed!");
    }
}
```
#### **What the Container Does:**
| **Lifecycle Stage** | **Container’s Role**                                                                 |
|---------------------|-------------------------------------------------------------------------------------|
| **Initialization**  | Calls `init()` once when the Servlet is first loaded (e.g., on startup or first request). |
| **Request Handling**| Creates threads to call `doGet()`, `doPost()`, etc., for each HTTP request.          |
| **Destruction**     | Calls `destroy()` when shutting down (e.g., to release database connections).        |

**Key Point:** You *never* call these methods directly—the container does!

---

### **2. Threading & Concurrency**
- The container **creates a new thread** for each incoming request (so multiple users can use the Servlet simultaneously).  
- Your `doGet()`/`doPost()` code must be **thread-safe** (avoid shared mutable state).  

#### **Example:**
```java
// UNSAFE (Shared variable across threads!)
public class BadServlet extends HttpServlet {
    int count = 0; // Danger! Race condition!
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
        count++;
    }
}
```
The container’s threading model is why Servlets are **scalable** but require careful coding.

---

### **3. Request/Response Handling**
The container wraps raw HTTP traffic into Java objects:  
- **`HttpServletRequest`**: Contains HTTP headers, parameters, body.  
- **`HttpServletResponse`**: Lets you set status codes, headers, and write output.  

#### **Behind the Scenes:**
1. You visit `http://localhost:8080/hello?name=Alice`.  
2. The container:  
   - Parses the URL and parameters.  
   - Creates `HttpServletRequest`/`HttpServletResponse` objects.  
   - Passes them to your `doGet()` method.  

---

### **4. Deployment & Configuration**
Servlets are deployed via:  
- **`web.xml` (Traditional)**  
  ```xml
  <web-app>
    <servlet>
      <servlet-name>hello</servlet-name>
      <servlet-class>com.example.HelloServlet</servlet-class>
    </servlet>
    <servlet-mapping>
      <servlet-name>hello</servlet-name>
      <url-pattern>/hello</url-pattern>
    </servlet-mapping>
  </web-app>
  ```
- **Annotations (Modern)**  
  ```java
  @WebServlet("/hello")
  public class HelloServlet extends HttpServlet { ... }
  ```
The container reads these and maps URLs to Servlets.

---

### **5. Memory & Resource Management**
- **Classloading**: The container loads/unloads Servlet classes (e.g., during hot deployment).  
- **Pooling**: Reuses Servlets instead of creating new instances per request.  
- **Cleanup**: Calls `destroy()` to release resources (e.g., closing database connections).  

---

### **6. Security**
The container handles:  
- Authentication (e.g., login pages).  
- Authorization (e.g., role-based access via `@RolesAllowed`).  
- HTTPS/SSL termination.  

---

### **7. Error Handling**
- Catches exceptions thrown by Servlets.  
- Shows default error pages or custom ones (configured in `web.xml`).  

---

### **Analogy: Restaurant Kitchen**
| **Container’s Job**         | **Restaurant Analogy**                          |
|-----------------------------|-----------------------------------------------|
| Manages Servlet lifecycle   | Hires chefs (`init()`), fires them (`destroy()`). |
| Handles threading           | Multiple chefs cook different orders at once.  |
| Wraps HTTP requests         | Waiter translates customer orders to recipes.  |
| Manages deployment          | Assigns chefs to stations (URL mappings).     |

---

### **Key Takeaways**
1. **Containers are invisible superheroes**: They handle everything low-level so you can focus on `doGet()`/`doPost()`.  
2. **Threading is automatic but dangerous**: Shared state causes bugs (race conditions).  
3. **Lifecycle matters**: Use `init()` for startup tasks (e.g., DB connections), `destroy()` for cleanup.  

---

### **Experiment to Try**
1. Add `System.out.println("Thread: " + Thread.currentThread().getId())` to your `doGet()`.  
   - Refresh the page multiple times—see different thread IDs!  
2. Add a `sleep(5000)` to simulate slow processing.  
   - Open two browser tabs—note how the container handles concurrent requests.  

This will solidify how containers manage Servlets in practice. Want to dive deeper into any area?



